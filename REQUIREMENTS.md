# ぬりえもん デスクトップアプリ版 要件定義書

## プロジェクト概要

### 背景
- 既存のWebアプリケーション「ぬりえもん」（oekaki-screen）をデスクトップアプリケーションとして再構築
- 元プロジェクト: `/Users/nga/oekaki-screen` (Webアプリ版)
- 新プロジェクト: `/Users/nga/nuriemon` (デスクトップ版)

ぬりえもんは子どもに楽しんでもらう為のツール。
自分の描いた絵や塗り絵が画面に反映して動くのが特徴。

### 目的
1. **オフライン運用（Localモード時）**: **Localモード時は**インターネット接続不要で全機能を利用可能に。**Relayモード時は**TLS経由で中継通信を行う。
2. **軽量化**: アプリケーションサイズを最小限に（目標: **本体**30MB以下。Python sidecar/モデルは別パッケージまたは初回取得）
3. **モダン化**: 1年以上前のコードベースを最新技術で刷新
4. **配布容易性**: 一般ユーザーが簡単にインストール・利用できる形に
5. **プロダクション品質**: 商用製品として販売可能な品質を確保
6. **運用モードの二重化**: **Auto/Relay/Local** の3モードで用途・現場環境に応じて切替可能（Phase 5以降）

## 開発品質基準

### コード品質要件
1. **プロダクションレディ**: 「とりあえず動く」コードは不可。商用製品として恥ずかしくない品質を維持
2. **アーキテクチャ優先**: 機能追加前に適切な設計を行い、技術的負債を作らない
3. **パフォーマンス重視**: ポーリングなど非効率な実装は避け、イベント駆動など適切なパターンを使用
4. **保守性**: 将来の機能追加・修正を考慮した拡張性のある設計
5. **一貫性**: コーディング規約、命名規則、ディレクトリ構造の統一

### AI開発者への指示
1. **実装前の設計**: 新機能実装前に必ずアーキテクチャ設計を提示し、承認を得ること
2. **改善提案の義務**: 実装完了後、より良い実装方法があれば必ず提案すること
3. **問題の早期報告**: 設計上の問題や技術的負債を発見したら即座に報告すること
4. **ベストプラクティス**: Tauriや各技術スタックのベストプラクティスに従うこと

### 品質チェックリスト
- [ ] コードは商用製品として適切な品質か
- [ ] パフォーマンスは最適化されているか
- [ ] エラーハンドリングは適切か
- [ ] セキュリティは考慮されているか
- [ ] 将来の拡張性は確保されているか
- [ ] テストは書かれているか（将来実装予定）

## 技術選定

### 採用技術スタック
- **フレームワーク**: Tauri v2 (Rust + WebView)
- **フロントエンド**: React 18+ with TypeScript
- **ビルドツール**: Vite
- **スタイリング**: CSS Modules + Sass (Tailwind CSSは不採用)
- **画像処理**: Python (rembg/U2Net) - **sidecarとしてバンドル**（本体と別パッケージ可）
- **ローカルDB**: SQLite
- **状態管理**: Zustand（実装済み）
- **（オンライン時）中継方式**: HTTPS + WebSocket（PC→中継サーバはアウトバウンド1本、スマホ→中継は4G/5G）

## 機能要件

### コア機能（既存機能の移植）
1. **画像アップロード・処理**
   - ローカルファイルシステムからの画像選択
   - AI背景除去機能（Python sidecar）
   - 処理済み画像のローカル保存

2. **アニメーション機能**
   - 画像の動き設定（移動、速度、サイズ、タイプ）
   - Canvas描画によるアニメーション表示
   - 音響効果（ローカル音源）

3. **ギャラリー機能**
   - 処理済み画像の一覧表示
   - 画像の管理（削除、編集）

### 新規要件
1. **自動アップデート機能**
   - アプリケーションの自動更新通知・実行
2. **動作モード切替（Auto/Relay/Local）**
   - 初期設定画面で「Auto（推奨）/Relay/Local」を選択（**デフォルト: Auto**）
   - **Auto**: Relay接続可能なら自動採用、不可/劣化時はLocalを案内
   - **Relay**: PCはインターネットへアウトバウンド接続し、中継サーバ経由でスマホと通信（スマホは4G/5Gのまま）
   - **Local**: PCローカルWebサーバーに対し、会場Wi‑Fi/PCホットスポット経由でスマホ接続（完全オフライン）

## 非機能要件

### パフォーマンス
- 起動時間: 3秒以内
- 画像処理: 1枚あたり5秒以内（背景除去）
- メモリ使用量: 500MB以下

### セキュリティ
- ローカルデータの暗号化（オプション）
- **外部通信なし（Localモード時）**。**Relayモード時**は中継サーバと**TLS通信**（WAF/Firewall Rules/レート制限適用）
- **トークン/ログ方針**:
  - QRは**短命・署名付き・ワンタイム**（60〜120秒）、**利用後失効**
  - **URLクエリにトークンを載せない**（Referer/ログ漏洩防止）。WSは `Sec-WebSocket-Protocol` または**初回メッセージ**で送信
  - トークン/JTIは**一部マスク**し、PII最小化。保持は短期（7〜14日）

### 配布
- Windows: MSIインストーラー（コード署名推奨）
- macOS: DMGファイル（公証対応）
- インストールサイズ: **本体**30MB以下目標（Python sidecar/モデルは別扱い）

## システムアーキテクチャ

### アーキテクチャ設計原則
1. **ワークスペースベース**: 各フォルダが独立したワークスペースとして機能
2. **マルチウィンドウ対応**: アニメーション機能など、独立したウィンドウで動作する機能を考慮
3. **イベント駆動**: ウィンドウ間通信はTauriのイベントシステムを使用
4. **データ一貫性**: SQLiteを中心としたデータ管理、ワークスペース単位での独立性
5. **責務の分離**: UI、ビジネスロジック、データアクセスの明確な分離

### ディレクトリ構造
```

nuriemon/
├── src-tauri/              # Tauriバックエンド (Rust)
│   ├── src/
│   │   ├── lib.rs          # メインライブラリ
│   │   ├── main.rs         # エントリーポイント
│   │   ├── db.rs           # SQLite操作
│   │   ├── events.rs       # イベントエミッター（ウィンドウ間通信）
│   │   └── workspace.rs    # ワークスペース管理
│   └── tauri.conf.json     # Tauri設定
├── src/                    # Reactフロントエンド
│   ├── App.tsx            # メインアプリケーション
│   ├── windows/           # ウィンドウ別エントリーポイント
│   │   └── AnimationWindow\.tsx
│   ├── components/        # UIコンポーネント
│   │   ├── WorkspaceSelector.tsx  # ワークスペース選択
│   │   └── SettingsPage.tsx       # 初期設定画面
│   ├── services/          # ビジネスロジック
│   │   ├── workspaceManager.ts    # ワークスペース管理
│   │   └── database.ts            # DB操作
│   ├── hooks/             # カスタムフック
│   │   └── useWorkspace.ts        # ワークスペースフック
│   ├── events/            # イベントリスナー管理
│   └── styles/            # Sass/CSSモジュール
├── python-sidecar/        # Python画像処理
│   ├── main.py           # エントリーポイント
│   ├── requirements.txt  # 依存関係
│   └── dist/             # PyInstallerビルド出力
└── vite.config.ts        # Vite設定

```

### ワークスペースアーキテクチャ
```

ワークスペース（フォルダ）
├── .nuriemon/              # ワークスペース専用データ
│   ├── nuriemon.db         # SQLiteデータベース
│   └── settings.json       # ワークスペース設定
├── images/                 # 画像ファイル
│   ├── originals/         # オリジナル画像
│   ├── processed/         # 処理済み画像
│   └── backgrounds/       # 背景画像
└── audio/                 # 音声ファイル
├── bgm-*.mp3         # BGM
└── soundEffect-*.mp3  # 効果音

```

### ウィンドウ間通信アーキテクチャ

#### イベント駆動アーキテクチャ（2025年1月実装）
```

Rust Backend → Tauriイベント → 中央リスナー → Zustandストア → Reactコンポーネント
↓                                                      ↑
ワークスペースDB ←─────────────────────────────────────────────→

````

##### 設計原則
1. **単一方向データフロー**: バックエンドからフロントエンドへの一方向のデータフロー
2. **Zustand中心の状態管理**:
   - 設定値（地面位置、削除時間など）はZustandストアで管理
   - 画像データなど大量のデータはDBを正とし、更新通知のみイベントで伝播
3. **疎結合な設計**: コンポーネント間の直接的な依存を排除

##### 実装詳細
- **TauriEventListener**: すべてのバックエンドイベントを受信し、適切な処理を行う中央リスナー
- **イベントの種類**:
  - `data-changed`: バックエンドからのデータ変更通知
  - `image-list-updated`: 画像リスト更新の内部通知（フロントエンド内）
  - `workspace-changed`: ワークスペース切り替え通知

## データ移行計画

### 既存システムからの変更
| 既存 (Web版) | 新規 (デスクトップ版) |
|------------|------------------|
| Firebase Auth | ローカル認証 (SQLite) |
| Firestore | SQLite |
| Cloud Storage | ローカルファイルシステム |
| SendGrid | システム通知 |
| オンライン共有 | ファイルエクスポート |

### データ保存場所

#### ワークスペースベースの保存
- **ワークスペース単位**: 各フォルダが独立した作業環境として機能
- **ポータブル性**: フォルダごと移動・コピーが可能
- **データの独立性**: ワークスペース間でデータは共有されない

#### グローバル設定の保存場所
- Windows: `%APPDATA%/nuriemon/global_settings.json`
- macOS: `~/Library/Application Support/nuriemon/global_settings.json`
- Linux: `~/.config/nuriemon/global_settings.json`

### ワークスペース管理
- 起動時に最後に使用したワークスペースを自動的に開く
- ワークスペース切り替え時は動的にDB接続を切り替え
- 各ワークスペースは`.nuriemon/`ディレクトリに設定とDBを保存

## 開発ロードマップ
### 設定の一本化（方針）
- 正: ワークスペース内の `.nuriemon/settings.json` と OS ごとの GlobalSettings（`global_settings.json`）。
- 旧: `src/services/settings.ts` および DB `app_settings` は廃止方向（起動時に移行のみ実施、以降は不使用）。
- コードはワークスペース絶対パスを正とし、旧「保存先種別（pictures/downloads/documents/appData/custom）」分岐は撤廃。

### Phase 1: 基盤構築（完了）
1. ✅ Tauriプロジェクトのセットアップ
2. ✅ 基本的なReact + TypeScript環境構築
3. ✅ SassとCSS Modulesの設定
4. ✅ Gitリポジトリの設定

### Phase 2: 基盤機能実装（完了）
1. ✅ **ファイル選択ダイアログの実装**
   - Tauriのファイルダイアログ APIを使用
   - 画像ファイル（.png, .jpg, .jpeg, .gif）のみ選択可能に

2. ✅ **ローカルファイルシステムAPIの設定**
   - 画像の保存・読み込み権限設定
   - アプリデータディレクトリの設定

3. ✅ **画像アップロード機能の実装**
   - 選択した画像のプレビュー表示
   - Canvasでの画像表示
   - 画像のローカル保存

### Phase 3: コア機能実装（完了）
4. ✅ **Python画像処理サービスの統合**
   - 背景除去機能の移植（rembg/U2Net使用）
   - Rust経由でPython実行
   - JSON形式でのプロセス間通信

5. ✅ **ギャラリー機能の実装**
   - 処理済み画像の一覧表示
   - サムネイル生成
   - 画像の削除・管理機能
   - メタデータ管理（JSON形式）

6. ✅ **保存先選択機能**
   - アプリデータ、ピクチャ、ダウンロード、ドキュメント、カスタムフォルダ選択
   - カスタムディレクトリへの保存（Rust側カスタムコマンド実装）
   - 設定の永続化

### Phase 4: 応用機能実装（完了）
1. ✅ **ローカルDB (SQLite)の設定**
   - 画像メタデータの移行（JSONからSQLiteへ）
   - ユーザー設定の保存
   - 処理履歴の管理
   - より高度なクエリ機能
   - 動き設定の保存機能

2. ✅ **アニメーション機能の移植**
   - 既存の動き設定（移動、速度、サイズ、タイプ）を移植
   - Canvasアニメーションの実装
   - プレビュー機能
   - 背景、BGM、効果音の設定機能

### Phase 4.5: 機能改善と修正（完了）
1. ✅ **マルチウィンドウアーキテクチャの実装**
   - Tauriイベントシステムの統合
   - ウィンドウ間のリアルタイム通信
   - イベント駆動への部分的な移行

2. ✅ **効果音再生の修正**
   - 初回画像追加時の効果音再生問題を解決
   - 音声プールの管理改善

3. ✅ **削除機能の改善**
   - ギャラリーからの削除ボタン修正
   - アニメーション画面の背景表示修正
   - Tauriネイティブダイアログに統一

### Phase 4.6: UI/UX改善（完了）
1. ✅ **アップロードページの機能分離**
   - 初期設定ページの作成
   - 高頻度機能（画像アップロード）の分離

2. ✅ **設定管理の統一化**
   - AppSettingsServiceへの完全移行
   - フォルダ設定の永続化修正
   - 背景の即時アップロード機能復元
   - エラーハンドリング強化

### Phase 4.7: 自動取り込み機能（完了）
1. ✅ **フォルダ監視による自動画像取り込み**
   - 指定フォルダの監視機能（Rust側でnotifyクレート使用）
   - 新規画像の自動検出と背景除去処理
   - スキャナー連携を想定した自動ワークフロー
   - ファイルシステムイベントによる効率的な実装
   - 重複画像の検出（ファイル名ベース）

2. ✅ **自動アニメーション設定**
   - 動きのプリセットパターン（normal, slow, fast, float, bounce, rotate, swim）
   - randクレートを使用した適切な乱数生成
   - 歩くタイプと飛ぶタイプの自動判定
   - ランダム性を持たせた自然な動き（速度: 0.5-1.5、サイズ: 0.8-1.2）

### Phase 4.8: アーキテクチャ改善（完了）
1. ✅ **Zustand統一アーキテクチャへの移行**
   - useDataChangeListenerフックを削除
   - TauriEventListenerによる中央集権的なイベント処理
   - WorkspaceManagerのイベント発行をZustandストア更新に置き換え
   - 状態管理の一元化と単一方向データフローの確立

2. ✅ **画像リアルタイム更新の修正**
   - ImageAdded/Deleted/SettingsChangedイベントの適切な処理
   - image-list-updatedイベントによる疎結合な更新通知
   - DBを単一の情報源とした堅牢な設計

### Phase 5: 子ども操作機能（QR紐付け + Auto/Relay/Local対応）
- **共通**: 画像アップロード時に個別QR表示、スマホをコントローラ化、WebSocketリアルタイム操作
- **Autoモード**:
  - 起動時に**Relay到達性プローブ**を実施（低頻度ヘルスチェック）
  - Relay健全 → **Public URLのQR**を表示、不可/劣化 → **Local案内**（Wi‑Fi接続手順/自己診断ページリンク）
- **Relayモード（オンライン）**:
  - PC→中継サーバ（HTTPS/WS）へアウトバウンド接続
  - スマホ（4G/5G）→中継のパブリックURLに接続、サーバが制御メッセージを中継
  - セッションは短命トークンで論理分離、**DB不要（メモリ/TTL/DO storage）**
  - **URLにトークンを載せない**（初回メッセージ or `Sec-WebSocket-Protocol`）
- **Localモード（オフライン）**:
  - PC内蔵Webサーバ（ローカル）にスマホを会場Wi‑Fi/PCホットスポットで接続
  - **自己診断ページ → 成功/失敗分岐案内 → Wi‑Fi接続QR** の順で誘導
  - AP隔離検知/案内、mDNS(.local)併記等で接続性を向上（将来）
- **フォールバック**: しきい値超過・障害時はUIでLocalへ切替ガイダンス（ワンタップ切替）
- **UI**: アニメーション画面にはQRコードを表示しない（観覧体験優先）
- **スマホUI**: シンプル/アドバンス切替、上下左右、アクション、エモート
  - シンプル: 幼児向け、エモート＋ランダムアクションのみ
  - 将来の挙動変更に備え、疎結合・設定駆動で実装

### Phase 6: ユーザー管理・配布準備（未実装）
1. **ユーザー管理機能**
   - マルチユーザー対応
   - プロファイル切り替え
   - 個別設定の保存
2. **配布用ビルド設定**
   - Windows用MSIインストーラー作成
   - macOS用DMGファイル作成
   - コード署名の設定
3. **自動アップデート機能**
   - アップデートチェック機能
   - 差分アップデートの実装
   - 更新通知UI

## 運用モード（Auto/Relay/Local）

### モード定義
- **Auto（推奨）**: 起動時にRelay到達性を**低頻度でプローブ**。健全ならRelay採用、不可/劣化時はLocal案内。
- **Relay（オンライン）**: 来場者は4G/5Gのまま、共通ドメインの中継サーバへ接続。PCは中継へアウトバウンド接続。画像/設定はPCローカル（SQLite/FS）。
- **Local（オフライン）**: 来場者は会場Wi‑FiまたはPCホットスポットに接続し、PCローカルサーバへ直接接続。

### 初期設定（UI）
- 初回起動時に「Auto（推奨）/Relay/Local」を選択可能（**デフォルト: Auto**）
- モードはワークスペース設定に保存し、いつでも変更可能（モード切替時はQR/接続先を出し分け）
- ランタイムでも**ステータスバーからワンタップ切替**できる（推奨）

### スケール目標
- 直近の運用想定: **同時1,000〜10,000接続**（Cloudflare Workers + Durable Objects で運用）
- 中長期の設計目標: **100×1000（会場×参加者）≒ 100,000接続**
- レイテンシ目標: **95p < 150ms（Relay時）**

### 推奨中継基盤（採用/候補）
- **採用**: **Cloudflare Workers + Durable Objects**（グローバル、低運用負荷、WS対応、セッションの強整合/ピン留めに最適）
- **代替候補**:
  - Fly.io（Rust/Actix、Anycast、オートスケール）
  - AWS（ALB+AutoScaling+ECS/Fargate、必要に応じRedis）
- いずれも「**単一ドメイン・共通基盤**」を全イベントで共用し、セッションを**トークンで論理分離**

## Relayアーキテクチャ（Cloudflare Workers + Durable Objects）

### オブジェクト粒度
- **EventDO**（イベント単位）: 参加者WS群の集約、レート制御、**イベント別キルスイッチ**
- **PcDO**（PC単位）: PCセッションの**順序保証/強整合**、スマホ↔PCの橋渡し

### エンドポイント/プロトコル
- `POST /e/{event_id}/session` → **短命署名トークン**を発行（claims: `exp`,`iat`,`jti`,`nonce`。TTL 60–120秒、**ワンタイム**）
- `GET /e/{event_id}/ws`（WS握手）
  - **禁止**: URLクエリにトークンを載せる
  - 方式A: `Sec-WebSocket-Protocol: bearer.<token>, v1`
  - 方式B: 初回メッセージでトークン送信（受理前は何も処理しない）
- **リージョンピン留め**: PCが先にPcDOへ接続して**近接リージョンに初期化**。スマホは同PcDOへルーティング

### QR/セッション交換（確定）
- QRは `e`（event_id）と `sid`（非秘匿の短命セッションID）だけを含む。
  - 例: `https://ctrl.nuriemon.jp/app/#e={event_id}&sid={sid}`（Crockford base32 10桁、TTL=90秒、I/O/L除外）
  - `sid` はPCが事前にEventDOへ「ペンディング登録」（TTL=90秒）してからQR化する。
- スマホは起動後、`POST /e/{event_id}/session` に `{ sid }` を送って、署名付きのワンタイムWSトークンを取得する（JTIはDO storageにTTL付き保持、ワンタイム担保）。
- WS接続は `GET /e/{event_id}/ws` に対して `Sec-WebSocket-Protocol: bearer.<token>, v1` を付与して行う（URLクエリにトークンは載せない）。
- WSは30〜45秒間隔のハートビートを実装し、スパイク時は 503 + `Retry-After` と指数バックオフ＋ジッターで安定化する。

#### Local/Relay のQR寿命ポリシー（正式）
- Local（オフライン）: 固定QR（長寿命）。会場内ネットワークでの到達性を最重視し、セッションは長時間有効（例: 24h）。
- Relay（オンライン）: 短命・ワンタイム（60–120秒）。`sid` は DO にTTL付きでpending登録、`/session` でJTIワンタイムのWSトークンを払い出し、使い切り（再利用不可）。

### 失効/JTIの保持
- **利用後失効（使い切り）**は **DOの`storage`（TTL付き）**にJTIを保存（**メモリ併用**）し、**再起動/スリープでも二重使用を防止**

### レート制限/スパイク対策
- イベント単位・IP単位・セッション単位のレート制限
- 同時大量入室に対し、**503 + `Retry-After`** と **指数バックオフ + ジッター**をクライアント必須実装

### バックプレッシャ/送信キュー
- クライアント別送信キューに**上限**（件数/バイト）を設定
- 超過時は同種イベントの**coalesce**（古い更新間引き）または対象クライアント一時ドロップ＋**再同期要求**

### メッセージ仕様（将来互換）
```json
{ "v": 1, "type": "join|cmd|ack|evt|error|hb", "sid": "...", "ts": 0, "payload": {...} }
````

* `v` と `type` は必須。`error.code` は列挙。将来は**MessagePack**に置換可能
* `permessage-deflate` は任意（CPU/帯域のトレードオフで選択）

### 署名正規化 v1（HMAC）
- 対象: `POST /e/{event_id}/register-pc`, `POST /e/{event_id}/pending-sid`
- 目的: EVENT_SETUP_SECRET による運営PCの正当性検証（偽PC/乱発防止）
- ヘッダ: `X-Relay-Iat`(UNIX秒), `X-Relay-Nonce`(16B base64url), `X-Relay-Sig`(base64url HMAC)
- 正規化: `op + "\n" + path + "\n" + payloadHash + "\n" + iat + "\n" + nonce`
  - `op`: `register-pc` | `pending-sid`
  - `path`: 例 `/e/demo-event/pending-sid`（スキーム/ホスト/クエリなし）
  - `payloadHash`: 生ボディの SHA-256 小文字hex（空は `e3b0c442...b855`）
  - 署名: HMAC-SHA256(secret, canonical) を base64url で送信
- ボディ(JSON):
  - register-pc: `{"pcid":"<[a-z0-9-]{3,32}>"}`
  - pending-sid: `{ "pcid":"...", "sid":"<base32-10>", "ttl":90 }`（TTLはサーバで[30,120]にクランプ）
- サーバ検証:
  1) iat±60s（外れは 401 E_CLOCK_SKEW + `X-Server-Time`）
  2) nonce 未使用（DO storage TTL=120s）
  3) payloadHash 一致（受信生ボディ）
  4) canonical を再構築し HMAC 検証
  5) 成功時: register-pc は PcDO 登録、pending-sid は pending 登録（重複sidは409 E_SID_EXISTS）
- エラー: 429/503 は必ず `Retry-After` を返却（クライアントは指数バックオフ＋ジッター）

## セキュリティ/運用

### マルチテナント/イベント分離

* ルーティング: `/e/{event_id}` または サブドメインで論理分離
* レート制限/クォータ: **イベント単位**・IP単位・セッション単位
* **キルスイッチ**: 特定イベントのみRelay停止→Local誘導

### 観測性/SLO

* **メトリクス**: 接続成功率、レイテンシ（p50/p95）、切断理由、再接続率、bps/接続
* **ダッシュボード**: イベント別リアルタイム表示
* **SLO**: 例）接続成功率 **99.5%**、95pレイテンシ **< 150ms**（Relay時）
* **アラート**: しきい値超過時に**UIへLocal誘導バナー**と**ワンタップ切替**を表示

### Local到達性改善（将来）

* QRは `http://<ip>:<port>` と `http://<hostname>.local` を併記
* **自己診断ページ → 成功/失敗の案内 → Wi‑Fi接続QR** の順で誘導
* APクライアント隔離の確認チェックリスト

### Auto継続プローブ（仕様明文化）
- プローブ対象: `/healthz`（2sタイムアウト、no‑store）を低頻度で実施。
- 採用条件: 連続N回成功、かつ `version===PROTOCOL_VERSION`、95pレイテンシしきい値内。
- 切替条件: 一定回数の連続失敗または 503/429 の誘導＋`Retry-After` を尊重。UIにLocal誘導バナーとワンタップ切替を提示。
- DoS時は指数バックオフ＋ジッターで負荷分散。

### CORS最小化（ローカル/Relay）
- Localサーバ: 基本は同一オリジンで配信し、不要な`Access-Control-Allow-*`ヘッダは付与しない。
- Relay(prod): `ALLOWED_ORIGINS = "https://ctrl.nuriemon.jp,tauri://localhost"`（Workers側設定）。

## AI開発者への最終注意

このプロジェクトは商用製品として販売予定です。
思考は英語でも構わないが、コミュニケーションは必ず日本語で。

「とりあえず動く」コードを書いた場合、それは技術的負債として後で必ず問題になります。
最初から正しく実装することで、長期的な開発効率と製品品質を保ちましょう。

## AIの役割

互いに協力しあい、より良いものを開発していけるように！

* **claude** = 実際にコードの追加や修正開発を行う役割。場当たり的な修正や開発をしがちなので要注意！
* **gemini** = コードはいじらず、claudeが行った修正プロセスとその結果について、チェッカーとして見解を述べる役割。チェックする際はちゃんと現状ファイル等を確認した上で回答するように。

  1. 多角的な視点: フロントエンドとバックエンド、両方の視点から問題を分析し、相互の影響を常に考慮します。
  2. 根本原因の追求: 表面的な解決策だけでなく、常に「なぜそうなったのか？」という根本原因を追求し、アーキテクチャレベルでの改善を提案します。
  3. 疑う姿勢: 提示された情報だけでなく、「他に考えられる可能性はないか？」と常に疑う姿勢を持ち、より広い視野で問題解決に取り組みます。
* **codex** = 本プロダクトの開発責任者の立ち位置。claudeやgeminiの改修やチェックに齟齬や誤りがないか確認しつつ、必要であれば、私に確認をとり、自らコード作成や開発を行う。
- ### セキュリティヘッダ（UI配信/リダイレクト時）
- - Content-Security-Policy: `default-src 'self'; connect-src 'self' wss://ctrl.nuriemon.jp`
- - Referrer-Policy: `no-referrer`
- - Strict-Transport-Security: `max-age=15552000`（preload/IncludeSubDomainsは当面オフ）
